import marimo as mo
import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
import json
import glob
import os
import plotly.graph_objects as go
from plotly.subplots import make_subplots
import warnings

warnings.filterwarnings("ignore")

# Set up plotting style
plt.style.use("seaborn-v0_8")
sns.set_palette("husl")
pd.set_option("display.max_columns", None)
pd.set_option("display.width", None)
pd.set_option("display.max_colwidth", None)

mo.md("# Life Insights Analysis")
mo.md(
    "This application analyzes journal reports generated by AI psychiatrists, tracking various psychological and emotional metrics over time."
)

mo.md("## Data Loading")
mo.md("Load the journal reports from the `~/tmp/monthly/` directory.")


@mo.cache
def load_reports():
    path_reports = glob.glob(
        os.path.expanduser("~/tmp/monthly/*gemini-2.5-pro-preview-06-05.json")
    )
    reports = []
    errors = []

    for path_report in sorted(path_reports):
        try:
            with open(path_report, "r") as f:
                data = json.load(f)
                filename = os.path.basename(path_report)
                date_str = filename.split("_")[0]
                data["filename"] = filename
                data["extracted_date"] = date_str
                reports.append(data)
        except Exception as e:
            errors.append((path_report, str(e)))

    return reports, errors


reports, load_errors = load_reports()
mo.md(f"Found {len(reports)} reports, with {len(load_errors)} loading errors.")


mo.md("## Data Processing")
mo.md("Extract and structure the key metrics from the reports.")


def extract_metrics(reports):
    """Extract key metrics from the reports into a structured format"""
    data = []

    for report in reports:
        try:
            if "Date" in report:
                date = pd.to_datetime(report["Date"])
            else:
                date = pd.to_datetime(report["extracted_date"])

            row = {
                "date": date,
                "doctor_name": report.get("DoctorName", "Unknown"),
                "filename": report.get("filename", ""),
            }

            for metric in [
                "Depression",
                "Anxiety",
                "Mania",
                "Happiness",
                "Satisfication",
            ]:
                if metric in report and isinstance(report[metric], dict):
                    row[f"{metric.lower()}_score"] = report[metric].get(
                        "scale_1_to_10", None
                    )
                    row[f"{metric.lower()}_reasoning"] = report[metric].get(
                        "reasoning_for_assessment", ""
                    )

            row["positive_causes_count"] = len(report.get("PostiveEmotionCause", []))
            row["negative_causes_count"] = len(report.get("NegativeEmotionCause", []))

            positive_emotions = report.get("PostiveEmotionCause", [])
            negative_emotions = report.get("NegativeEmotionCause", [])

            row["avg_positive_intensity"] = (
                np.mean([cause.get("scale_1_to_10", 0) for cause in positive_emotions])
                if positive_emotions
                else 0
            )
            row["avg_negative_intensity"] = (
                np.mean([cause.get("scale_1_to_10", 0) for cause in negative_emotions])
                if negative_emotions
                else 0
            )

            row["category_summaries_count"] = len(report.get("CategorySummaries", []))
            row["people_mentioned_count"] = len(report.get("PeopleInEntry", []))
            row["recommendations_count"] = len(report.get("Recommendations", []))
            row["mentioned_days_count"] = len(report.get("MentionedDays", []))

            data.append(row)

        except Exception as e:
            print(f"Error processing report {report.get('filename', 'unknown')}: {e}")
            continue

    return pd.DataFrame(data)


df = extract_metrics(reports)
df = df.sort_values("date").reset_index(drop=True)

mo.md(
    f"Processed {len(df)} reports, from {df['date'].min().strftime('%Y-%m-%d')} to {df['date'].max().strftime('%Y-%m-%d')}"
)
mo.ui.table(df.head())


mo.md("## Basic Statistics Overview")

metrics = [
    "depression_score",
    "anxiety_score",
    "mania_score",
    "happiness_score",
    "satisfication_score",
]
summary_data = []
for metric in metrics:
    if metric in df.columns:
        valid_scores = df[metric].dropna()
        if len(valid_scores) > 0:
            summary_data.append(
                {
                    "Metric": metric.replace("_", " ").title(),
                    "Mean": f"{valid_scores.mean():.2f}",
                    "Std": f"{valid_scores.std():.2f}",
                    "Range": f"[{valid_scores.min()}, {valid_scores.max()}]",
                }
            )
mo.ui.table(pd.DataFrame(summary_data))

mo.md("## Time Series Analysis")
mo.md("Visualize how key psychological metrics trend over time.")


def plot_time_series():
    fig, axes = plt.subplots(2, 3, figsize=(18, 12))
    axes = axes.flatten()
    metric_colors = ["red", "orange", "purple", "green", "blue"]
    for i, (metric, color) in enumerate(zip(metrics, metric_colors)):
        if metric in df.columns:
            valid_data = df[df[metric].notna()]
            if len(valid_data) > 0:
                axes[i].plot(
                    valid_data["date"],
                    valid_data[metric],
                    marker="o",
                    linewidth=2,
                    markersize=6,
                    color=color,
                    alpha=0.7,
                )
                axes[i].set_title(
                    f"{metric.replace('_', ' ').title()} Over Time",
                    fontsize=14,
                    fontweight="bold",
                )
                axes[i].set_ylabel("Score (1-10)", fontsize=12)
                axes[i].grid(True, alpha=0.3)
                axes[i].tick_params(axis="x", rotation=45)
                z = np.polyfit(range(len(valid_data)), valid_data[metric], 1)
                p = np.poly1d(z)
                axes[i].plot(
                    valid_data["date"],
                    p(range(len(valid_data))),
                    "--",
                    alpha=0.8,
                    color="black",
                    linewidth=1,
                )
    if len(metrics) < len(axes):
        fig.delaxes(axes[-1])
    plt.tight_layout()
    return fig


plot_time_series()

mo.md("## Interactive Dashboard with Plotly")


def create_dashboard():
    fig = make_subplots(
        rows=2,
        cols=2,
        subplot_titles=(
            "Psychological Metrics Over Time",
            "Emotion Causes Distribution",
            "Engagement Metrics",
            "Correlation Heatmap",
        ),
        specs=[
            [{"secondary_y": True}, {"type": "bar"}],
            [{"type": "scatter"}, {"type": "heatmap"}],
        ],
    )
    colors = ["red", "orange", "purple", "green", "blue"]
    for i, (metric, color) in enumerate(zip(metrics, colors)):
        if metric in df.columns:
            valid_data = df[df[metric].notna()]
            if len(valid_data) > 0:
                fig.add_trace(
                    go.Scatter(
                        x=valid_data["date"],
                        y=valid_data[metric],
                        mode="lines+markers",
                        name=metric.replace("_", " ").title(),
                        line=dict(color=color, width=2),
                        marker=dict(size=6),
                    ),
                    row=1,
                    col=1,
                )

    emotion_data = df[["positive_causes_count", "negative_causes_count"]].mean()
    fig.add_trace(
        go.Bar(
            x=["Positive Causes", "Negative Causes"],
            y=emotion_data.values,
            marker_color=["green", "red"],
            name="Emotion Causes",
        ),
        row=1,
        col=2,
    )

    fig.add_trace(
        go.Scatter(
            x=df["people_mentioned_count"],
            y=df["recommendations_count"],
            mode="markers",
            name="Engagement",
            marker=dict(
                size=8,
                color=df["happiness_score"],
                colorscale="Viridis",
                showscale=True,
                colorbar=dict(title="Happiness Score"),
            ),
            text=df["date"].dt.strftime("%Y-%m-%d"),
            hovertemplate="People: %{x}<br>Recommendations: %{y}<br>Date: %{text}",
        ),
        row=2,
        col=1,
    )

    corr_columns = [
        "depression_score",
        "anxiety_score",
        "happiness_score",
        "satisfication_score",
        "positive_causes_count",
        "negative_causes_count",
    ]
    corr_data = df[corr_columns].corr()
    fig.add_trace(
        go.Heatmap(
            z=corr_data.values,
            x=corr_data.columns,
            y=corr_data.columns,
            colorscale="RdBu",
            zmid=0,
            name="Correlation",
            text=np.round(corr_data.values, 2),
            texttemplate="%{text}",
            textfont={"size": 10},
        ),
        row=2,
        col=2,
    )

    fig.update_layout(
        height=800, title_text="Life Insights Dashboard", title_x=0.5, showlegend=True
    )
    fig.update_xaxes(title_text="Date", row=1, col=1)
    fig.update_yaxes(title_text="Score (1-10)", row=1, col=1)
    fig.update_xaxes(title_text="People Mentioned", row=2, col=1)
    fig.update_yaxes(title_text="Recommendations Count", row=2, col=1)
    return fig


create_dashboard()

app = mo.App()
